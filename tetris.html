<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8">
    <title>TETRIS</title>
    <style>
        canvas {
            border: 2px solid black;
        }
    </style>
</head>
<body>
    <h1>TETRIS</h1>
    <canvas id="GameCanvas" width="600px" height="600px">
       
    </canvas>
    
<script type="text/javascript">


//all the variable come in here
const COL = 12;
const ROW = 22;
const blockSize = 25;

const gridHeight = blockSize * ROW; 
const gridWidth = blockSize * COL;

var x = 50;
var y = 30;
let currentX = 4;
let currentY = 0;
let currentColor = "rgb(255, 0, 0)";


var field = [
    [1,1,1,1,0,0,0,0,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1],

];
// テトリスの形
const I = [
	[
		[0, 0, 0, 0],
		[1, 1, 1, 1],
		[0, 0, 0, 0],
		[0, 0, 0, 0],
	],
	[
		[0, 0, 1, 0],
		[0, 0, 1, 0],
		[0, 0, 1, 0],
		[0, 0, 1, 0],
	],
	[
		[0, 0, 0, 0],
		[0, 0, 0, 0],
		[1, 1, 1, 1],
		[0, 0, 0, 0],
	],
	[
		[0, 1, 0, 0],
		[0, 1, 0, 0],
		[0, 1, 0, 0],
		[0, 1, 0, 0],
	]
];

const J = [
	[
		[1, 0, 0],
		[1, 1, 1],
		[0, 0, 0]
	],
	[
		[0, 1, 1],
		[0, 1, 0],
		[0, 1, 0]
	],
	[
		[0, 0, 0],
		[1, 1, 1],
		[0, 0, 1]
	],
	[
		[0, 1, 0],
		[0, 1, 0],
		[1, 1, 0]
	]
];

const L = [
	[
		[0, 0, 1],
		[1, 1, 1],
		[0, 0, 0]
	],
	[
		[0, 1, 0],
		[0, 1, 0],
		[0, 1, 1]
	],
	[
		[0, 0, 0],
		[1, 1, 1],
		[1, 0, 0]
	],
	[
		[1, 1, 0],
		[0, 1, 0],
		[0, 1, 0]
	]
];

const O = [
	[
		[0, 0, 0, 0],
		[0, 1, 1, 0],
		[0, 1, 1, 0],
		[0, 0, 0, 0],
	]
];

const S = [
	[
		[0, 1, 1],
		[1, 1, 0],
		[0, 0, 0]
	],
	[
		[0, 1, 0],
		[0, 1, 1],
		[0, 0, 1]
	],
	[
		[0, 0, 0],
		[0, 1, 1],
		[1, 1, 0]
	],
	[
		[1, 0, 0],
		[1, 1, 0],
		[0, 1, 0]
	]
];

const T = [
	[
		[0, 1, 0],
		[1, 1, 1],
		[0, 0, 0]
	],
	[
		[0, 1, 0],
		[0, 1, 1],
		[0, 1, 0]
	],
	[
		[0, 0, 0],
		[1, 1, 1],
		[0, 1, 0]
	],
	[
		[0, 1, 0],
		[1, 1, 0],
		[0, 1, 0]
	]
];

const Z = [
	[
		[1, 1, 0],
		[0, 1, 1],
		[0, 0, 0]
	],
	[
		[0, 0, 1],
		[0, 1, 1],
		[0, 1, 0]
	],
	[
		[0, 0, 0],
		[1, 1, 0],
		[0, 1, 1]
	],
	[
		[0, 1, 0],
		[1, 1, 0],
		[1, 0, 0]
	]
];

const blocks = [I, J, L, O, S, T, Z];

let currentBlockShape = blocks[0][0];

const fallingInterval = 1000; 


let lastDropTime = 0;
const dropInterval = fallingInterval;




//-------------------------------------------------------------

    
	   //メインループ関数
function loop(timestamp) {
	
	onDraw();
	dropBlock(timestamp);
	window.requestAnimationFrame(loop);
  } 

function drawBackgroundAndGrid(x = 50, y = 30, width = gridWidth, height = gridHeight) {

	//Get the context to draw
	const canvas = document.getElementById("GameCanvas");
	const context = canvas.getContext("2d");

	//Fill the entire canvas black as the background color
	context.fillStyle = "black";
    context.fillRect(x,y,width,height);

	//grid: draw vertical line of the frame
	for (let i = x; i<= x + width; i+= blockSize){
            context.beginPath();
            context.moveTo(i, y);
            context.lineTo(i, y + height);
            context.stroke();
       }
    //grid: draw horizontal line
    for (let i = y; i<= y + height; i += blockSize){
            context.beginPath();
            context.moveTo(x, i);
            context.lineTo(x + width, i);
            context.stroke(); 
        }

        context.strokeStyle = "white";
        context.lineWidth = 3;
}
drawBackgroundAndGrid();

	//描画処理関数
function onDraw() {

	const canvas = document.getElementById("GameCanvas");
    const context = canvas.getContext("2d");

    drawBackgroundAndGrid(); // Call drawBackgroundAndGrid() here
    
    function drawSingleBlock(x,y,color){
        context.fillStyle = color;
        context.fillRect(x,y,blockSize, blockSize);
        context.strokeRect(x,y,blockSize,blockSize);

    }

    function drawFixedBlocks(){
        for (let r = 0; r < field.length; r++){
            for (let c = 0; c < field[r].length; c++){
                if(field[r][c]===1){
                    drawSingleBlock(x + c*blockSize,y + r*blockSize,"gray");
                }
            }
        }
    } // end drawFixedBlocks()
   drawFixedBlocks();

    
    function drawCurrentBlock (x, y, color){
        for (let r = 0; r < currentBlockShape.length; r++){
            for (let c = 0; c < currentBlockShape[r].length; c++){
                if(currentBlockShape[r][c]===1){
                    let newX = x + c;
                    let newY = y + r;
                    // Adjust the position to account for field starting at x = 50, y = 30
                    let adjustedX = newX * blockSize + 50; // Adjusting for x = 50
                    let adjustedY = newY * blockSize + 30; // Adjusting for y = 30
                    // Check if the new position is within the field boundaries
                    if(newX >= 0 && newX < gridWidth && newY >= 0 && newY <gridHeight) {
                        drawSingleBlock(adjustedX,adjustedY,color);
                }
            }
        }      
    }
    }

    drawCurrentBlock(currentX,currentY,currentColor);

	function unDraw() {
		for (let r = 0; r < currentBlockShape.length; r++) {
    		for (let c = 0; c < currentBlockShape[r].length; c++) {
				if(currentBlockShape[r][c]===1){
					const x = (currentX + c) * blockSize + 50;
					const y = (currentY + r) * blockSize + 30;
					context.clearRect(x,y,blockSize, blockSize);
        			drawBackgroundAndGrid(x, y, blockSize, blockSize);				
			}
		}
	}
}
    
//----------------------------------------------------------------

function isBottom() {
  for (let r = 0; r < currentBlockShape.length; r++) {
    for (let c = 0; c < currentBlockShape[r].length; c++) {
      if (currentBlockShape[r][c] === 1) {
        const newX = currentX + c;
        const newY = currentY + r;

        // Check if any cell of the current block has reached the bottom row of the field
        if (newY === ROW - 1) {
          return true; // Reached the bottom of the field
        }

        // Check if any cell of the current block is above an existing block
        if (field[newY + 1] && field[newY + 1][newX] === 1) {
          return true; // Reached the bottom (an existing block)
        }
      }
    }
  }

  return false; // Not at the bottom
}

function isCollidedLeft() {
	for (let r=0; r< currentBlockShape.length;r++) {
		for (let c=0;c<currentBlockShape[r].length;c++){
			if(currentBlockShape[r][c]===1){
				const newX = currentX + c;
				//Check if any cell of the current block would be outside the left boundary
				if(newX===1){
					return true;
				}
			}
		}
	}
	return false; // no collision with the left wall
}

function isCollidedRight() {
  for (let r = 0; r < currentBlockShape.length; r++) {
    for (let c = 0; c < currentBlockShape[r].length; c++) {
      if (currentBlockShape[r][c] === 1) {
        const newX = currentX + c;

        // Check if any cell of the current block has reached the rightmost column (the wall)
        if (newX === COL - 2) {
          return true; // Collided with the right wall
        }
      }
    }
  }

  return false; // No collision with the right wall
}

function fixCurrentBlock() {
	for (let r = 0; r < currentBlockShape.length; r++) {
    	for (let c = 0; c < currentBlockShape[r].length; c++) {
			if(currentBlockShape[r][c]===1){
				const newX = currentX + c;
				const newY= currentY + r;

				// update the field array with the current block's position
				field[newY][newX]=1;
			}
		}
	}
}

function checkLines() {
	let linesToRemove = [];

	//check each row for completes
	for (let r=0; r <ROW; r++) {
		let isLineComplete = true;
		for (let c = 0; c <COL; c++) {
			if(field[r][c]===0) {
				isLineComplete = false;
				break;
				}
			}
		if(isLineCompleted) {  //If the line is complete, add it to the lineToRemove array
			linesToRemove.push(r);
		}
	}
	//remove complete lines
	if (linesToRemove.length > 0){
		removeLines(linesToRemove);
		updateScore(linesToRemove.length);
	}
}



function removeLines(linesToRemove) {
	//remove the complete lines from the field
	for (let r = linesToRemove.length -1; r>= 0; r--){
		field.splice(linesToRemove[r], 1);
	}

	//add new empty rows at the top
	for (let i = 0; i < linesToRemove.length; i++) {
    field.unshift(Array(COL).fill(0));
  }
}

function updateScore(linesCleared) {
	//update the score based on the number of lines cleared
	score += linesCleared; //1 point per a line cleared 
}

function createNewBlock(blockIndex) {
        currentX = 4;
        currentY = 0;
        currentColor = "red";
        blockIndex = Math.floor(Math.random() * blocks.length);
        currentBlockShape = blocks[blockIndex][0];

		//clear the existing interval
		clearInterval(intervalId);

		//set new interval
		intervalId = setInterval(dropBlock, fallingInterval);
    } //end createNewBlock(blockIndex)



function moveLeft(){
	if (!isCollidedLeft()) {
		unDraw();
		currentX--; //decrement X coordinate to move left
		drawCurrentBlock(currentX,currentY,currentColor);
	}
}

function moveRight() {
	if(!isCollidedRight()){
		unDraw();
		currentX++; //increment the X coordinate to move right
		drawCurrentBlock(currentX,currentY,currentColor);
	}
}

function moveDown() {
	if(!isBottom()){
		unDraw();
		currentY ++; //increment the Y coordinate to move down
		drawCurrentBlock(currentX,currentY, currentColor);
	}
	else{
		//current block has reach the bottom
		fixCurrentBlock();
		checkLines();
		createNewBlock();
		
	}
}
function rotate() {
  let newBlockShape;
  let offsetX = 0;
  let offsetY = 0;

  // Rotate the block shape
  const oldBlockShape = currentBlockShape;
  newBlockShape = oldBlockShape.map((row, y) =>
    row.map((value, x) => oldBlockShape[oldBlockShape.length - 1 - x][y])
  );

  // Check for collisions after rotation
  for (let r = 0; r < newBlockShape.length; r++) {
    for (let c = 0; c < newBlockShape[r].length; c++) {
      if (newBlockShape[r][c] === 1) {
        const newX = currentX + c + offsetX;
        const newY = currentY + r + offsetY;

        // Check for collisions with walls and existing blocks
        if (
          newX < 0 ||
          newX >= COL ||
          newY >= ROW ||
          (newY >= 0 && field[newY][newX] === 1)
        ) {
          // Collision detected, do not rotate
          return;
        }
      }
    }
  }

  // Update the current block shape and position
  currentBlockShape = newBlockShape;
  currentX += offsetX;
  currentY += offsetY;

  // Redraw the current block after rotation
  drawCurrentBlock(currentX, currentY, currentColor);
}

document.addEventListener("keydown", onKeyDown);

function onKeyDown(event) {
  switch (event.keyCode) {
    case 37: // Left arrow
      if (!isCollidedLeft()) {
        moveLeft();
      }
      break;
    case 39: // Right arrow
      if (!isCollidedRight()) {
        moveRight();
      }
      break;
    case 38: // Up arrow
      rotate();
      break;
    case 40: // Down arrow
      if (!isBottom()) {
        moveDown();
      } else {
        // Current block has reached the bottom
        fixCurrentBlock();
        checkLines();
      }
      break;
  }
}



function dropBlock(timestamp) {
    if (!isBottom()) {
		const elapsedTime = timestamp - lastDropTime;
		if(elapsedTime >= dropInterval){
			unDraw();
        	currentY++;
			drawCurrentBlock(currentX, currentY, currentColor);
			lastDropTime = timestamp; //update the last drop time
		}    
    } 	else {
		
    	fixCurrentBlock();
    	checkLines();
		createNewBlock();
	}
}

    
    

} //end onDraw()



    

	//メインループ開始
window.requestAnimationFrame(loop)
</script>
</body>
</html>