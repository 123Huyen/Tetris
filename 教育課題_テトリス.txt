■Step1. 画面に枠線を描画する

・ベースとなるHTMLファイル、tetris.htmlを作成する。
内容は以下の通り。
<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8">
    <title>TETRIS</title>
</head>
<body><canvas id="GameCanvas" width="600px" height="600px"></canvas></body>
<script type="text/javascript">
	//メインループ関数
	function loop(timestamp) {
	  onDraw()
	  window.requestAnimationFrame(loop)
	}

	//描画処理関数
	function onDraw() {
		//描画対象のコンテキストを取得
		let canvas = document.getElementById("GameCanvas");
		let context = canvas.getContext("2d");
		
		//画面描画の命令はここに記載する
		
	}

	//メインループ開始
	window.requestAnimationFrame(loop)
</script>
</html>


・CADやゲーム等に代表される、グラフィックスを自前で描画するソフトウェアの一般的な構造として、
　メインループという繰り返し処理を持つ。
　この繰り返し処理の中で、各種ロジックや描画処理を実行する。

・onDraw内に以下の命令を追加する。
　・背景色としてcanvas全体を黒く塗りつぶす
　・縦22段×横12列の格子状に枠線を描画する
　　線を描画する際、forループを使用すること。
　・枠線の左上端のCanvas上の座標がx:50,y:30となること。
　・枠線の色は白。
　・枠線の線幅は3ピクセル。
　・枠線同士の間隔は25ピクセル。
　・各定数はソースコードの冒頭にconstとして定義し、変更してもその通りに動作するようにする。



■Step2. 壁を塗りつぶす

・フィルード上に設置されたブロックの情報を管理する二次元配列を作成する。(22段,12列)
　(配列のイメージ)
　　[
　　　　[1,1,1,1,0,0,0,0,1,1,1,1],
　　　　[1,0,0,0,0,0,0,0,0,0,0,1],
　　　　[1,0,0,0,0,0,0,0,0,0,0,1],
　　　　[1,0,0,0,0,0,0,0,0,0,0,1],
　　　　[1,0,0,0,0,0,0,0,0,0,0,1],
　　　　[1,0,0,0,0,0,0,0,0,0,0,1],
　　　　[1,0,0,0,0,0,0,0,0,0,0,1],
　　　　[1,0,0,0,0,0,0,0,0,0,0,1],
　　　　[1,0,0,0,0,0,0,0,0,0,0,1],
　　　　[1,0,0,0,0,0,0,0,0,0,0,1],
　　　　[1,0,0,0,0,0,0,0,0,0,0,1],
　　　　[1,0,0,0,0,0,0,0,0,0,0,1],
　　　　[1,0,0,0,0,0,0,0,0,0,0,1],
　　　　[1,0,0,0,0,0,0,0,0,0,0,1],
　　　　[1,0,0,0,0,0,0,0,0,0,0,1],
　　　　[1,0,0,0,0,0,0,0,0,0,0,1],
　　　　[1,0,0,0,0,0,0,0,0,0,0,1],
　　　　[1,0,0,0,0,0,0,0,0,0,0,1],
　　　　[1,0,0,0,0,0,0,0,0,0,0,1],
　　　　[1,0,0,0,0,0,0,0,0,0,0,1],
　　　　[1,1,1,1,1,1,1,1,1,1,1,1]
　　]
　　※0が何もない場所1が壁を表す。

・二次元配列の内容に従って、ブロック位置を塗りつぶす関数drawFixedBlocksを作成する。
　⇒配列のサイズに従ってループ処理で塗りつぶしを行う。

・1マス分を塗りつぶす関数drawSingleBlock(x,y)を作成する。引数は塗りつぶすマスの位置を表す。
　⇒引数は必要なら追加しても良い。
　⇒塗りつぶす際、枠線を消さないようにすること。
　⇒0の場合背景色。1の場合グレーで塗りつぶす。



■Step3. 上端中央にブロックを1ます塗りつぶす

・現在のブロックの位置、色を表すグローバル変数currentX, currentY, currenColorを定義する。
・初期値にcurrentX=4, currentY=0, currnetColor="rgb(255, 0, 0)"を設定する
・currentX, currentYの位置に、currentColor色で1マスのブロックを描画し塗りつぶす関数drawCurrentBlockを作成する
・drawCurrentBlock関数内でブロックを描画する処理は、drawSinbleBlock関数を呼ぶこと。
・drawSingleBlockの引数を追加し、塗りつぶす色を渡せるようにする。



■Step4. ブロックを1秒間隔で1つずつ下に移動させ、下端で停止させる

・ブロックの降下間隔を表す定数を定義する。値は1000。単位はミリ秒。
・dropBlock関数を作成しcerrentXを1加算する。
・isBottom関数を作成し、currentXが下端を指す場合True、それ以外の場合Falseを返す。
・メインループ開始の次にタイマーを開始する。
　⇒setInterval関数を使い、定数に定義された間隔(1000ミリ秒)毎にdropBlock関数を呼び出す。
・dropBlock内でisBottom関数を呼び、戻り値がTrueだった場合clearInterval関数を呼びタイマーを取消す。



■Step5. ブロックが積みあがるようにする

・isBottomを改造し、現在ブロックの直下がフィルード上で0以外である場合Trueを返すようにする。
・createNewBlock()を作成し、現在ブロック位置を初期化し、タイマーを開始する。
・isBottomがTrueを返した場合、ブロックの現在位置に、移動中ブロックの値 = 2を設定し、createNewBlock()を呼ぶ。
・積みあがったブロックは、落下中と同じ色で描画されること。



■Step6. ブロックをキーボードで移動させる

・カーソルキーの左右キーで現在のブロックを左右に移動できるようにする。
・カーソルキーの下キーで現在のブロックを素早く降下できるようにする。
・左右の移動先が0以外の場合、1マス左右に移動する。
・下キー押下時もブロックが積みあがるようにする。



■Step7. ブロックが停止した時に、揃った段を消去する。

・isBottomがTrueを返した場合、フィールドの全段を照会し、全てブロックで埋まっている場合、
　その段のブロックを消去し、より上段のブロックを落下させる。
　この段階でありえないが、複数段が同時で消えても正しく落下するよう注意する。
　
　(イメージ)
　　　　□　　　　□　　　□　　　　□
　　　　□■■　　□　　　□　　　　□
　　　　□■■■■□　　　□　　　　□
　　　　□　■■　□　⇒　□■■　　□
　　　　□■■■■□　　　□　■■　□
　　　　□□□□□□　　　□□□□□□



■Step8. 徐々に落下速度をアップする

・ブロックを一つ停止させる毎に、ブロック落下の間隔を10ms短くする。
・最大100msまで落下間隔を短くする。



■Step9. 落下するブロックを複数ブロックの塊にする

・ブロックの形を定義する二次元配列を定義する。
・本STEPでは以下の一種類のブロックを定義する。
　
　(イメージ)　テトリスの直線■■■■を表す。
　　[
　　　　[0,0,0,0],
　　　　[1,1,1,1],
　　　　[0,0,0,0],
　　　　[0,0,0,0]
　　}

・drawCurrentBlockを改造し、上記の二次元配列を元に複数ブロックが描画できるようにする。
　⇒二次元配列の先頭[0][0]の位置を、フィールド上のcurrentY, currentXとして捉えて、
　　ループ処理で、二次元配列内に1が設定された箇所に塗りつぶしを行う。

・複数ブロックの塊による当たり判定を行うisCollided(x, y)関数を作成する。
　⇒上記の二次元配列のデータを元に、x, yの位置にフィルード上に0以外が設定されている場合はTrueを返す。
　⇒右キー移動の処理を改造し、isCollided(currentX + 1, currentY)がTrueの場合は移動しないようにする。
　⇒左キー移動の処理を改造し、isCollided(currentX - 1, currentY)がTrueの場合は移動しないようにする。
　⇒ブロック落下の処理を改造し、isCollided(currentX, currentY + 1)がTrueの場合は移動しないようにする。
　
・isBottomがTrueを返した場合、ブロックの現在位置に移動中ブロックの値 = 2を設定する処理を改造し、
　上記の二次元配列のデータと同じ形に、ブロックの値を書き込むようにする。



■Step10.ブロックを回転させる

・ブロックの形を定義した二次元配列を拡張し、ブロックの方向別の形も定義する三次元配列にする。

　(イメージ)
　　{
　　　　[
　　　　　　[0,0,0,0],
　　　　　　[1,1,1,1],
　　　　　　[0,0,0,0],
　　　　　　[0,0,0,0]
　　　　},
　　　　[
　　　　　　[0,1,0,0],
　　　　　　[0,1,0,0],
　　　　　　[0,1,0,0],
　　　　　　[0,1,0,0]
　　　　}
　　}
　
　　※[ブロックの向き][y][x]を表す。

・落下中ブロックの現在の方向を保持する変数currentOrientation = 0を定義する。
・スペースキーで図形を時計回りに回転させる。
　⇒[currentOrientation][currentY][currentX]のような関係となるよう注意する。
　⇒このブロックの場合は、2種類しか存在しないので、currentOrientationは 0 or 1だが、
　　ブロックの向きが何種類になっても対応できるプログラムにすること。

・回転時も回転後の当たり判定を行い、ブロックが衝突する場合は回転しない。
　⇒isCollided()を拡張し、現在位置で回転場合に衝突するブロックがある場合にTrueを返せるようにする。
　⇒isCollided()がFalseを返した場合に正式に現在のブロックを回転させる。(currentOrientationを加算する)

・ブロックが停止した場合はcurrentOrientationを0で初期化する。


■Step11. ブロックを7種類に増やし、ランダムに出現させる

⇒ブロックの種類を以下の7種類定義する。また回転した形も同様に定義する。カッコ内は回転による形違いの種類。

　■■■■　(2)
　
　■■　　　(1)
　■■
　
　　■　　　(4)
　■■■
　
　■■　　　(2)
　　■■
　
　　■■　　(2)
　■■
　
　■　　　　(4)
　■■■
　
　　　■　　(4)
　■■■

⇒startNewBlockで生成するブロックの種類を乱数で決定する。

⇒ブロックの種類毎に表示色を変える。積みあがったブロックも落下中と同じ色で塗りつぶされること、



■Step12. 上まで積みあがった場合にゲームオーバーにする

・ブロックがスタート地点でisBottom()==Trueとなった場合ゲームオーバーとする。
・ゲームオーバーになったら画面中央に「GAME OVER　HIT SPACE KEY」と表示する。
・スペースキー押下で、ゲームを最初から再開できる。



■Step13. 次に出現するブロックを表示する

・画面右側に次に出現するブロックを表示する。



■Step14. 得点を設定し表示する

・一度に消したライン数によって獲得できる特典を変える。



■--. 予備知識

この課題の実行環境であるWebブラウザの場合、
onDraw()に記載したようなグラフィックコンテキストにグラフィックを描画する処理と、
requestAnimationFrame()が完全にシーケンシャルに呼び出されるので必要ありませんが、
GDIやDirectXなど、多くのグラフィック環境では「ダブルバッファリング」という技術が必要になります。
興味があれば調べてみてください。


以上
